## Binary Bomb (Phase 1-4, 25 + 50 + 75 + 150pts)

#### Description

Welcome to the CyberDawgs Binary Bomb  challenge series! The "bbomb" binary contains a series of mini reversing challenges broken into 9 phases.  Each phase becomes incresingly more  difficult, but it is not required to solve a phase to move onto the  next.  Simply press enter for a phase's input to skip it.  Additionally, known phase solutions can be stored in a file named "flags.txt".  See  the binary's welcome message for the format and requirements.  When  submitting to this scoreboard, wrap the phase's solution in DawgCTF{}.   Happy reversing! Author: treap_treap

#### Phase 1

**Description**

Starting off easy... reversing (things) is fun!

**Solution**

The binary contains all 9 phases + a bonus. Phase 1 as the description suggests is very trivial. By looking at the decompilation for `phase1`, we see:

```c
puts(str: "\nStarting off easy... reversing…")
int32_t var_34 = 1
char* rax = calloc(n: 0x29, elem_size: 1)
getInput(1, arg1, data_2831, 0)
int32_t var_30 = 0
int32_t rax_3 = strlen(rax)
while (true)
    if (sx.q(var_30) u>= strlen("Gn1r7s_3h7_Gn15Rev3R"))
        break
    if (sx.q(var_30) u>= strlen(rax))
        break
    if (*("Gn1r7s_3h7_Gn15Rev3R" + sx.q(var_30)) != *(rax + sx.q(rax_3 - var_30) - 1))
        var_34 = 0
    var_30 = var_30 + 1
if (sx.q(var_30) != strlen("Gn1r7s_3h7_Gn15Rev3R"))
    var_34 = 0
free(mem: rax)
return zx.q(var_34)
```

It's just a string reversal. So `R3veR51nG_7h3_s7r1nG` is the flag string.



#### Phase 2

**Description**

Can you help me find my lost key so I can read my string?

**Solution**

This one's also fairly straightforward and common.

```c
puts(str: "\nCan you help me find my lost k…")
int32_t var_30 = 1
char* rax = calloc(n: 0x29, elem_size: 1)
getInput(2, arg1, data_2831, 0)
int32_t var_2c = 0
while (true)
    if (sx.q(var_2c) u>= strlen("Dk52m6WZw@s6w0dIZh@2m5a"))
        break
    if (sx.q(var_2c) u>= strlen(rax))
        break
    if (*("Dk52m6WZw@s6w0dIZh@2m5a" + sx.q(var_2c)) != (*(rax + sx.q(var_2c)) ^ 5))
        var_30 = 0
    var_2c = var_2c + 1
if (sx.q(var_2c) != strlen("Dk52m6WZw@s6w0dIZh@2m5a"))
    var_30 = 0
free(mem: rax)
return zx.q(var_30)
```

As you can see with the presence of `^`, it's an XOR operation against a static key (5). By simply reversing the XOR, you can get the flag, being `An07h3R_rEv3r5aL_mE7h0d`.



#### Phase 3

**Description**

Reflections? Rotations? Translations? This is starting to sound like geometry...

**Solution**

Phase 3 was where it started getting a bit more interesting. Since this challenge is not as trivial as the first two, I'll put my reversed / cleaned up code of the relevant functions instead of just decompiler output.

```c
int64_t phase3(char *savedflag)
{
    char in[0x29];
    getInput(stdin, savedflag, "%s", &in);
    
    for(int i = 0; i < strlen(in); i++)
    {
        char transformedChar = c;
        transformedChar = func3_1(transformedChar);
        transformedChar = func3_2(transformedChar);
        in[i] = transformedChar;
    }
    
    if(strcmp(in, "\"_9~Jb0!=A`G!06qfc8'_20uf6`2%7") == 0)
    {
        return 1; // success
    }
    
    return 0;
}

char func3_1(char in)
{
    char base;
    
    if(in > 0x40 && in < 0x5A)
    {
        in = in - 0xD;
        base = 0x1A;
        
        if(in > 0x40)
            base = 0;
        
        in = base + in;
    }
    
    if(in > 0x60 && in < 0x7A)
    {
        in = in - 0xD;
        base = 0x1A;
        
        if(in > 0x60)
            base = 0;
        
        in = base + in;
    }
    
    return in;
}

char func3_2(char in)
{
    char base;
    
    if(in > 0x20 && in != 0x7F)
    {
        in = in - 0x2F;
        
        if(in > 0x20)
            base = 0;
        else
            base = 0x5E;
        
        in = base + in;
    }
    
    return in;
}
```

Basically it applies to transformations on each character. It first runs a pass on letters (the uppercase range in `0x40 - 0x5A`, the lowercase in `0x60 - 0x7A`). It then runs another pass on all characters. We could implement a function to reverse these transformations, but for the sake of time we can just bruteforce it by throwing our reversed functions into a program and writing a loop to brute each character.

```c
/* func3_1 and func3_2 here */

int main()
{
    char ctfStr[] = "\"_9~Jb0!=A`G!06qfc8'_20uf6`2%7";
    int ctfStrLen = strlen(ctfStr);
    
    for(int i = 0; i < ctfStrLen; i++)
    {
        for(int c = 0x20; c < 0x7F; c++)
        {
            char transformedChar = c;
            transformedChar = transform_one(transformedChar);
            transformedChar = transform_two(transformedChar);
            
            if(transformedChar == ctfStr[i])
            {
                printf("%c", c);
            }
        }
    }
    
    printf("\nDone!\n");

    return 0;
}
```

Which gives us: `D0uBl3_Cyc1iC_rO74tI0n_S7r1nGs`.



#### Phase 4

**Description**

This is the phase you have been waiting for... one may say it's the golden stage!

Let's switch things up! Numerical inputs map to line numbers in  rockyou.txt, and each word is separated by a '_' (if the phase's  solution is 4 5, the flag would be DawgCTF{password_iloveyou})

rockyou.txt: https://github.com/brannondorsey/naive-hashcat/releases/download/data/rockyou.txt

**Solution**

This phase took quite a bit more time to get through than the previous challenges, and was my favorite phase that I solved. Again, below is my reversed code.

```c
int64_t func4(int arg)
{
    if(arg <= 0)
        return 0;
    else if(arg != 1)
        return func4(arg - 2) + func4(arg - 1);
    return 1;
}

int64_t phase4(char *savedflag)
{
    int success = 1;
    int inputs[4];
    int correct[4];
    
    getInput(stdin, savedflag, "%d%d%d%d", &in);
    
    correct[0] = 1;
    correct[1] = 0x7B;
    correct[2] = 0x3B18;
    correct[3] = 0x1C640D;
    
    for(int i = 0; i < 4; i++)
    {
        if(func4(inputs[i]) != (int64_t)(correct[i]) * func4(0xA))
            success = 0;
    }
    
    return success;
}
```

I'm not a math person so I didn't put it together right away, but after doing some searching I discovered `func4` is a fibonacci calculation function. Given the fact that using large values would be very expensive computationally, we can reasonably assume the input keys are going to be small, likely sub-100. By running a similar function to phase 3, we can bruteforce the input key.

```c
int correct[4];
    
correct[0] = 1;
correct[1] = 0x7B;
correct[2] = 0x3B18;
correct[3] = 0x1C640D;

int key = fibonacci(0xA);
    
for(int i = 0; i < 4; i++)
{
    for(int j = 5; j < 100; j++)
    {
        if(fibonacci(j) == key * correct[i])
        {
            printf("input %d = %d\n", i, j);
            break;
        }
    }
}
```

Which gives us:

```
input 0 = 10                             
input 1 = 20                     
input 2 = 30                  
input 3 = 40 
```

Using the wordlist provided, we get the following words:

```
10 = abc123
20 = qwerty
30 = anthony
40 = 123123
```

Therefore the flag is: `abc123_qwerty_anthony_123123`



#### Final flags

Phase 1: `DawgCTF{R3veR51nG_7h3_s7r1nG}`

Phase 2: `DawgCTF{An07h3R_rEv3r5aL_mE7h0d}`

Phase 3: `DawgCTF{D0uBl3_Cyc1iC_rO74tI0n_S7r1nGs}`

Phase 4: `DawgCTF{abc123_qwerty_anthony_123123}`